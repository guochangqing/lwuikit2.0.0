package six.lwuikit.tip;import six.lwuikit.tip.TipAnimation.onTransformationListener;import android.app.Application;import android.content.Context;import android.graphics.Color;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.text.TextUtils;import android.util.TypedValue;import android.view.Gravity;import android.view.ViewParent;import android.view.WindowManager;import android.view.WindowManager.LayoutParams;import android.view.animation.Animation;import android.view.animation.Animation.AnimationListener;import android.view.animation.DecelerateInterpolator;import android.widget.FrameLayout;import android.widget.LinearLayout;import android.widget.TextView;public class Tip {	private static final int MSG_HIDE = 0x0001;		private static final int DEFAULT_INTERVAL_TIME = 2000 ;		private WindowManager mWindowManager;		private boolean showable = true;		private FrameLayout root;		private LinearLayout animationview;		private TextView textview;		private int fontSize = 28;		private int fontColor = Color.WHITE;		private int tipHeight = LayoutParams.WRAP_CONTENT;		private int backgroundColor = Color.GRAY;		private Handler mHandler;		private LayoutParams localLayoutParams;		private float interpolated = 0.0f;		private enum TipStatus{		IDLE,		OPENWAIT,		OPENING,		SHOWING,		CLOSEWAIT,		CLOSEING;	}	private TipStatus curstatus = TipStatus.IDLE;		private DecelerateInterpolator defaultInterpolator;	private Tip() {}	private static class Singleton {		private static Tip mTip = new Tip();	}	public static Tip makeTip() {		return Singleton.mTip;	}	public void init(Application context) {		if(null == defaultInterpolator) {			defaultInterpolator = new DecelerateInterpolator();		}		if(null == localLayoutParams){			localLayoutParams = new WindowManager.LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.WRAP_CONTENT ,					  LayoutParams.TYPE_SYSTEM_ERROR, 8520488, -3);			localLayoutParams.gravity = Gravity.TOP;		}		if(null == mHandler) {			mHandler = new Handler(Looper.getMainLooper()){				@Override				public void handleMessage(Message msg) {					myHandleMessage(msg);				}			};		}		if(null == mWindowManager) {			mWindowManager =(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);		}		if(null == root){			createView(context);		}	}	public void showTip(final String msg) {		if(null == msg || !showable) {			return;		}		if(Looper.myLooper() == Looper.getMainLooper()) {			show(msg);			return;		}		mHandler.post(new Runnable(){			@Override			public void run() {				// TODO Auto-generated method stub				show(msg);			}		});	}	public void hideTip() {		synchronized (this) {			if(curstatus != TipStatus.IDLE) {				removeMsg();				mWindowManager.removeView(root);				curstatus = TipStatus.IDLE;				cancelAnimation();			}		}	}	private void show(String msg) {		synchronized (this) {			if(null == textview) {				return;			}			textview.setText(msg);			if(curstatus == TipStatus.IDLE) {				//直接执行				curstatus = TipStatus.OPENWAIT;				ViewParent parent = root.getParent();				if(null == parent) {					mWindowManager.addView(root, localLayoutParams);				}				animationview.startAnimation(createInAnimation(-1.0f,0.0f));			}else if(curstatus == TipStatus.OPENWAIT ||					curstatus == TipStatus.OPENING ) {							}else if(curstatus == TipStatus.SHOWING) {				sendMsg();			}else if(curstatus == TipStatus.CLOSEWAIT || 					curstatus == TipStatus.CLOSEING) {				curstatus = TipStatus.OPENWAIT;				cancelAnimation();			}		}	}		private Animation createInAnimation(float f_y,float t_y) {		TipAnimation mAnimationIn = new TipAnimation(Animation.RELATIVE_TO_SELF,				0, Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_SELF,				f_y, Animation.RELATIVE_TO_SELF, t_y);		mAnimationIn.setDuration(500);		mAnimationIn.setInterpolator(defaultInterpolator);		mAnimationIn.setOnTransformationListener(in);		mAnimationIn.setAnimationListener(inlistener);		return mAnimationIn;	}	private Animation createOutAnimation(float f_y,float t_y) {		TipAnimation mAnimationOut = new TipAnimation(Animation.RELATIVE_TO_SELF,				0, Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_SELF,				f_y, Animation.RELATIVE_TO_SELF, t_y);		mAnimationOut.setDuration(500);		mAnimationOut.setInterpolator(defaultInterpolator);		mAnimationOut.setOnTransformationListener(out);		mAnimationOut.setAnimationListener(outlistener);		return mAnimationOut;	}	private void myHandleMessage(Message msg) {		synchronized (this) {			if(null != msg && msg.what == MSG_HIDE) {				interpolated = 1.0f;				curstatus = TipStatus.CLOSEWAIT;				animationview.startAnimation(createOutAnimation(0.0f,-1.0f));			}		}	}	private void removeMsg() {		if(null != mHandler && mHandler.hasMessages(MSG_HIDE)){			mHandler.removeMessages(MSG_HIDE);		}	}	private void sendMsg() {		if(null != mHandler){			if(mHandler.hasMessages(MSG_HIDE)) {				mHandler.removeMessages(MSG_HIDE);			}			mHandler.sendEmptyMessageDelayed(MSG_HIDE, DEFAULT_INTERVAL_TIME);		}	}	private void cancelAnimation() {		if(null != animationview){			animationview.clearAnimation();		}	}	private void createView(Context context) {		root = new FrameLayout(context);		animationview = new LinearLayout(context);		root.addView(animationview, new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.WRAP_CONTENT));		animationview.setBackgroundColor(backgroundColor);		textview = new TextView(context);		textview.setTextColor(fontColor);		textview.setTextSize(TypedValue.COMPLEX_UNIT_PX, fontSize);		textview.setMaxLines(2);		textview.setGravity(Gravity.CENTER);		textview.setEllipsize(TextUtils.TruncateAt.END);		animationview.addView(textview, new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT,tipHeight));	}		private AnimationListener inlistener = new AnimationListener(){		@Override		public void onAnimationStart(Animation animation) {			synchronized (this) {				if(curstatus == TipStatus.OPENWAIT) {					curstatus = TipStatus.OPENING;				}			}		}		@Override		public void onAnimationEnd(Animation animation) {			// TODO Auto-generated method stub			synchronized (this) {				if(curstatus == TipStatus.OPENWAIT) {					curstatus = TipStatus.OPENING;				}				if(curstatus == TipStatus.OPENING) {					sendMsg();					curstatus = TipStatus.SHOWING;				}			}		}		@Override		public void onAnimationRepeat(Animation animation) {}			};	private AnimationListener outlistener = new AnimationListener(){		@Override		public void onAnimationStart(Animation animation) {			synchronized (this) {				if(curstatus == TipStatus.CLOSEWAIT) {					curstatus = TipStatus.CLOSEING;				}else if(curstatus == TipStatus.OPENWAIT) {					curstatus = TipStatus.OPENING;				}			}		}		@Override		public void onAnimationEnd(Animation animation) {			// TODO Auto-generated method stub			synchronized (this) {				if(curstatus == TipStatus.CLOSEWAIT) {					curstatus = TipStatus.CLOSEING;				}else if(curstatus == TipStatus.OPENWAIT) {					curstatus = TipStatus.OPENING;				}				if(curstatus == TipStatus.OPENING) {					animationview.startAnimation(createInAnimation(-interpolated,0.0f));				}else if(curstatus == TipStatus.CLOSEING) {					mWindowManager.removeView(root);					curstatus = TipStatus.IDLE;				}			}		}		@Override		public void onAnimationRepeat(Animation animation) {}			};	private onTransformationListener in = new onTransformationListener() {		@Override		public void onTransformation(TipAnimation animation,				float interpolatedTime) {			// TODO Auto-generated method stub			if(curstatus == TipStatus.OPENING) {				interpolated = interpolatedTime;			}		}	};	private onTransformationListener out = new onTransformationListener() {		@Override		public void onTransformation(TipAnimation animation,				float interpolatedTime) {			// TODO Auto-generated method stub			if(curstatus == TipStatus.CLOSEING) {				interpolated = interpolatedTime;			}		}	};	public void setShowable(boolean s) {		showable = s;	}		public boolean getShowable() {		return showable;	}	public int getFontSize() {		return fontSize;	}	public void setFontSize(int fontSize) {		this.fontSize = fontSize;		if(null != textview){			textview.setTextSize(TypedValue.COMPLEX_UNIT_PX, fontSize);		}	}	public int getFontColor() {		return fontColor;	}	public void setFontColor(int fontColor) {		this.fontColor = fontColor;		if(null != textview){			textview.setTextColor(fontColor);		}	}		public int getTipHeight() {		return tipHeight;	}	public void setTipHeight(int tipHeight) {		this.tipHeight = tipHeight;		if(null != textview){			textview.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT,tipHeight));		}	}	public int getBackgroundColor() {		return backgroundColor;	}	public void setBackground(int color) {		this.backgroundColor = color;		if(null != animationview){			animationview.setBackgroundColor(color);		}	}}