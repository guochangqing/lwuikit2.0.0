package six.lwuikit.common;import six.lwuikit.saf.RE;import android.annotation.SuppressLint;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Paint.Align;import android.graphics.Paint.FontMetricsInt;import android.graphics.Rect;import android.text.InputType;import android.util.AttributeSet;import android.util.SparseArray;import android.view.KeyEvent;import android.view.MotionEvent;import android.view.VelocityTracker;import android.view.ViewConfiguration;import android.view.animation.DecelerateInterpolator;import android.widget.EditText;import android.widget.NumberPicker;import android.widget.Scroller;public class WheelView extends NumberPicker{		private static final int SELECTOR_WHEEL_STATE_NONE = 0;	private static final int SELECTOR_WHEEL_STATE_SMALL = 1;	private static final int SELECTOR_WHEEL_STATE_LARGE = 2;		private static final int SELECTOR_WHEEL_BRIGHT_ALPHA = 255;	private static final int SELECTOR_MAX_FLING_VELOCITY_ADJUSTMENT = 1;		private static final int HCVIEW_COLOR = 0xffffff;	private static final int HCVIEW_FOCUSED_COLOR = 0xF54696;		private static final int INIT_SCROLL_OFFSET_HORIZONTAL = 0;	private static final int INIT_SCROLL_OFFSET_VERTICAL = 0;		private static final int MIN_WIDTH = 0;	private static final int MIN_HEIGHT = 0;		private static final int SIZE_UNSPECIFIED = -1;		private static final int SELECTOR_ADJUSTMENT_DURATION_MILLIS = 800;		private static final int SHOW_INPUT_CONTROLS_DELAY_MILLIS = ViewConfiguration			.getDoubleTapTimeout();		private static final float TOP_AND_BOTTOM_FADING_EDGE_STRENGTH = 0.9f;		private int mSolidColor;	private boolean mComputeMaxWidth;	private int mMaxWidth;	private int mMaxHeight;	private int mSelectorWheelState;	private Paint mSelectorWheelPaint;	private int mTouchSlop;	private int mMinimumFlingVelocity;	private int mMaximumFlingVelocity;	private int mTextSize = 40;	private int mTextColor = HCVIEW_COLOR;	private int mTextFocusedColor = HCVIEW_FOCUSED_COLOR;	private int mLongScaleLineColor = HCVIEW_COLOR;	private int mLongScaleLineFocusedColor = HCVIEW_FOCUSED_COLOR;		private Scroller mFlingScroller;	private Scroller mAdjustScroller;		private boolean mFlingable;	private boolean mScrollWheelAndFadingEdgesInitialized = false;		private SparseArray<String> mSelectorIndexToStringCache = new SparseArray<String>();		private int[] SELECTOR_INDICES_LARGE = new int[] {			Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE,            };	private int[] mSelectorIndices = SELECTOR_INDICES_LARGE;	private int mSelectorMiddleItemIndex = mSelectorIndices.length / 2;		private boolean mHorizontal = true;		private float mLastDownEventY;	private float mLastDownEventX;	private float mLastMotionEventY;	private float mLastMotionEventX;		private int mSelectorTextGapWidth;	private int mSelectorTextGapHeight;	private int mSelectorElementWidth;	private int mSelectorElementHeight;		private int mInitialScrollOffset = Integer.MIN_VALUE;	private int mCurrentScrollOffset;		private boolean mWrapSelectorWheel;	private int mMaxValue;	private int mMinValue;	private String[] mDisplayedValues;	private Formatter mFormatter;	private int mValue;	private AdjustScrollerCommand mAdjustScrollerCommand;		private int mPreviousScrollerY;	private int mPreviousScrollerX;		private boolean mBeginEditOnUpEvent;	private boolean mAdjustScrollerOnUpEvent;		private int mScrollState = OnScrollListener.SCROLL_STATE_IDLE;		private OnScrollListener mOnScrollListener;		private VelocityTracker mVelocityTracker;		private OnValueChangeListener mOnValueChangeListener;		private OnTouchListener mOnTouchListener;		private float mScaleLengthShort = 10;	private float mMarginTopOfLabel = 18;	private float mLongScaleWidth = 1;		public WheelView(Context context) {		this(context,null,0);	}	public WheelView(Context context, AttributeSet attrs) {		this(context,attrs,0);	}	public WheelView(Context context, AttributeSet attrs, int defStyle) {		super(context, attrs, defStyle);		init(context);		TypedArray a = context.obtainStyledAttributes(attrs, RE.styleable_WheelView);		if(null != a){			int index = RE.get(RE.ATTR_WV_TEXTCOLOR);			if(index >= 0){				setTextColor(a.getColor(index, HCVIEW_COLOR));			}			index = RE.get(RE.ATTR_WV_TEXTFOCUSEDCOLOR);			if(index >= 0){				setTextFocusedColor(a.getColor(index, HCVIEW_FOCUSED_COLOR));			}			index = RE.get(RE.ATTR_WV_LONGSCALELINECOLOR);			if(index >= 0){				setLongScaleLineColor(a.getColor(index, HCVIEW_COLOR));			}			index = RE.get(RE.ATTR_WV_LONGSCALELINEFOCUSEDCOLOR);			if(index >= 0){				setLongScaleLineFocusedColor(a.getColor(index, HCVIEW_FOCUSED_COLOR));			}			index = RE.get(RE.ATTR_WV_SCALELENGTHSHORT);			if(index >= 0){				setScaleLengthShort((int)a.getDimension(index, 10));			}			index = RE.get(RE.ATTR_WV_MARGINTOPOFLABEL);			if(index >= 0){				setMarginTopOfLabel((int)a.getDimension(index, 18));			}			index = RE.get(RE.ATTR_WV_LONGSCALEWIDTH);			if(index >= 0){				setLongScaleWidth((int)a.getDimension(index, 1));			}			index = RE.get(RE.ATTR_WV_TEXTSIZE);			if(index >= 0){				setTextSize((int)a.getDimension(index, 40));			}			index = RE.get(RE.ATTR_WV_HORIZONTAL);			if(index >= 0){				setHorizontal(a.getBoolean(index, true));			}			a.recycle();		}	}		private void init(Context context) {		setBackgroundColor(Color.TRANSPARENT);		mSolidColor = Color.BLACK;		mFlingable = true;		mComputeMaxWidth = (mMaxWidth == Integer.MAX_VALUE);		setWillNotDraw(false);		setSelectorWheelState(SELECTOR_WHEEL_STATE_NONE);		ViewConfiguration configuration = ViewConfiguration.get(context);		mTouchSlop = configuration.getScaledTouchSlop();		mMinimumFlingVelocity = configuration.getScaledMinimumFlingVelocity();		mMaximumFlingVelocity = configuration.getScaledMaximumFlingVelocity()				/ SELECTOR_MAX_FLING_VELOCITY_ADJUSTMENT;				mSelectorWheelPaint = new Paint();		mSelectorWheelPaint.setAntiAlias(true);		mSelectorWheelPaint.setTextAlign(Align.CENTER);		mSelectorWheelPaint.setTextSize(mTextSize);		mSelectorWheelPaint.setColor(mTextColor);				mFlingScroller = new Scroller(getContext(), null, true);		mAdjustScroller = new Scroller(getContext(),				new DecelerateInterpolator(2.5f));				if (mFlingable) {			if (isInEditMode()) {				setSelectorWheelState(SELECTOR_WHEEL_STATE_SMALL);			} else {				setSelectorWheelState(SELECTOR_WHEEL_STATE_LARGE);			}		}		setFocusable(false);		EditText et = (EditText)this.getChildAt(1);		if(et != null){			et.setInputType(InputType.TYPE_NULL);		}	}//		private void setSelectorWheelState(int selectorWheelState) {		mSelectorWheelState = selectorWheelState;		if (selectorWheelState == SELECTOR_WHEEL_STATE_LARGE) {			mSelectorWheelPaint.setAlpha(SELECTOR_WHEEL_BRIGHT_ALPHA);		}	}		@Override	protected void onLayout(boolean changed, int left, int top, int right,			int bottom) {		if (!mScrollWheelAndFadingEdgesInitialized) {			mScrollWheelAndFadingEdgesInitialized = true;			initializeSelectorWheel();			initializeFadingEdges();		}		setVerticalFadingEdgeEnabled(false);	}		public void setTextSize(int textSize) {		if (textSize > 0) {			mTextSize = textSize;			mSelectorWheelPaint.setTextSize(textSize);		}	}		public void setScale(int scaleCnt) {		if (SELECTOR_INDICES_LARGE.length != scaleCnt) {			SELECTOR_INDICES_LARGE = new int[scaleCnt];			for(int i = 0; i < scaleCnt; i++){				SELECTOR_INDICES_LARGE[i] = Integer.MIN_VALUE;			}			mSelectorIndices = SELECTOR_INDICES_LARGE;			mSelectorMiddleItemIndex = mSelectorIndices.length / 2;			if(mSelectorMiddleItemIndex < mMinValue){				mSelectorMiddleItemIndex = mMinValue;			}			initializeSelectorWheel();		}	}		@Override	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {		try {			final int newWidthMeasureSpec = makeMeasureSpec(widthMeasureSpec,					mMaxWidth);			final int newHeightMeasureSpec = makeMeasureSpec(heightMeasureSpec,					mMaxHeight);			super.onMeasure(newWidthMeasureSpec, newHeightMeasureSpec);			// Flag if we are measured with width or height less than the			// respective			// min.			final int widthSize = resolveSizeAndStateRespectingMinSize(					MIN_WIDTH, getMeasuredWidth(), widthMeasureSpec);			final int heightSize = resolveSizeAndStateRespectingMinSize(					MIN_HEIGHT, getMeasuredHeight(), heightMeasureSpec);			setMeasuredDimension(widthSize, heightSize);		} catch (Exception ex) {			ex.printStackTrace();		}	}		private int makeMeasureSpec(int measureSpec, int maxSize) {		if (maxSize == SIZE_UNSPECIFIED) {			return measureSpec;		}		final int size = MeasureSpec.getSize(measureSpec);		final int mode = MeasureSpec.getMode(measureSpec);		switch (mode) {		case MeasureSpec.EXACTLY:			return measureSpec;		case MeasureSpec.AT_MOST:			return MeasureSpec.makeMeasureSpec(Math.min(size, maxSize),					MeasureSpec.EXACTLY);		case MeasureSpec.UNSPECIFIED:			return MeasureSpec.makeMeasureSpec(maxSize, MeasureSpec.EXACTLY);		default:			throw new IllegalArgumentException("Unknown measure mode: " + mode);		}	}		private int resolveSizeAndStateRespectingMinSize(int minSize,			int measuredSize, int measureSpec) {		if (minSize != SIZE_UNSPECIFIED) {			final int desiredWidth = Math.max(minSize, measuredSize);			return resolveSizeAndState(desiredWidth, measureSpec, 0);		} else {			return measuredSize;		}	}		@Override	public boolean onInterceptTouchEvent(MotionEvent event) {		if (!isEnabled() || !mFlingable) {			return false;		}		switch (event.getActionMasked()) {		case MotionEvent.ACTION_DOWN:			mLastMotionEventY = event.getY();			mLastDownEventY = event.getY();			mLastMotionEventX = event.getX();			mLastDownEventX = event.getX();			removeAllCallbacks();			mBeginEditOnUpEvent = false;			mAdjustScrollerOnUpEvent = true;			if (mSelectorWheelState == SELECTOR_WHEEL_STATE_LARGE) {				mSelectorWheelPaint.setAlpha(SELECTOR_WHEEL_BRIGHT_ALPHA);				boolean scrollersFinished = mFlingScroller.isFinished()						&& mAdjustScroller.isFinished();				if (!scrollersFinished) {					mFlingScroller.forceFinished(true);					mAdjustScroller.forceFinished(true);					onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);				}				mBeginEditOnUpEvent = scrollersFinished;				mAdjustScrollerOnUpEvent = true;				return true;			}			mAdjustScrollerOnUpEvent = false;			setSelectorWheelState(SELECTOR_WHEEL_STATE_LARGE);			return true;		case MotionEvent.ACTION_MOVE:			float currentMoveY = event.getY();			int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);			if (mHorizontal) {				if (mLastDownEventX > mTouchSlop) {					mBeginEditOnUpEvent = false;					onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);					return true;				}			} else {				if (deltaDownY > mTouchSlop) {					mBeginEditOnUpEvent = false;					onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);					return true;				}			}			break;		default: {			break;		}		}		return false;	}		private void removeAllCallbacks() {		if (mAdjustScrollerCommand != null) {			removeCallbacks(mAdjustScrollerCommand);		}	}		private void onScrollStateChange(int scrollState) {		if (mScrollState == scrollState) {			return;		}		mScrollState = scrollState;		if (mOnScrollListener != null) {			mOnScrollListener.onScrollStateChange(this, scrollState);		}	}		@Override	public boolean onTouchEvent(MotionEvent ev) {		if (!isEnabled()) {			return false;		}		if (mVelocityTracker == null) {			mVelocityTracker = VelocityTracker.obtain();		}		mVelocityTracker.addMovement(ev);		int action = ev.getActionMasked();		switch (action) {		case MotionEvent.ACTION_DOWN: 		case MotionEvent.ACTION_CANCEL:		{			if(null != mOnTouchListener) {				mOnTouchListener.onTouch(this, ev);			}			break;		}		case MotionEvent.ACTION_MOVE:			if(null != mOnTouchListener) {				mOnTouchListener.onTouch(this, ev);			}			if (!mHorizontal) {				float currentMoveY = ev.getY();				if (mBeginEditOnUpEvent						|| mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {					int deltaDownY = (int) Math.abs(currentMoveY							- mLastDownEventY);					if (deltaDownY > mTouchSlop) {						mBeginEditOnUpEvent = false;						onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);					}				}				int deltaMoveY = (int) (currentMoveY - mLastMotionEventY);				scrollBy(0, deltaMoveY);				invalidate();				mLastMotionEventY = currentMoveY;			} else {				float currentMoveX = ev.getX();				if (mBeginEditOnUpEvent						|| mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {					int deltaDownX = (int) Math.abs(currentMoveX							- mLastDownEventX);					if (deltaDownX > mTouchSlop) {						mBeginEditOnUpEvent = false;						onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);					}				}				int deltaMoveX = (int) (currentMoveX - mLastMotionEventX);				scrollBy(deltaMoveX, 0);				invalidate();				mLastMotionEventX = currentMoveX;			}			break;		case MotionEvent.ACTION_UP:			if(null != mOnTouchListener) {				mOnTouchListener.onTouch(this, ev);			}			if (mBeginEditOnUpEvent) {				setSelectorWheelState(SELECTOR_WHEEL_STATE_SMALL);				return true;			}			VelocityTracker velocityTracker = mVelocityTracker;			velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);			int initialVelocity = 0;			if (!mHorizontal) {				initialVelocity = (int) velocityTracker.getYVelocity();			} else {				initialVelocity = (int) velocityTracker.getXVelocity();			}			if (Math.abs(initialVelocity) > mMinimumFlingVelocity) {				// fling after up				fling(initialVelocity);				onScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);			} else {				if (mAdjustScrollerOnUpEvent) {					if (mFlingScroller.isFinished()							&& mAdjustScroller.isFinished()) {						postAdjustScrollerCommand(0);					}				} else {					postAdjustScrollerCommand(SHOW_INPUT_CONTROLS_DELAY_MILLIS);				}			}			mVelocityTracker.recycle();			mVelocityTracker = null;			break;		default: {			break;		}		}		return true;	}		@Override	public boolean dispatchTouchEvent(MotionEvent event) {		final int action = event.getActionMasked();		switch (action) {		case MotionEvent.ACTION_MOVE:			if (mSelectorWheelState == SELECTOR_WHEEL_STATE_LARGE) {				removeAllCallbacks();				forceCompleteChangeCurrentByOneViaScroll();			}			break;		case MotionEvent.ACTION_CANCEL:		case MotionEvent.ACTION_UP:			removeAllCallbacks();			break;		default: {			break;		}		}		return super.dispatchTouchEvent(event);	}		@Override	public boolean dispatchKeyEvent(KeyEvent event) {		int keyCode = event.getKeyCode();		if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER				|| keyCode == KeyEvent.KEYCODE_ENTER) {			removeAllCallbacks();		}		return super.dispatchKeyEvent(event);	}	@Override	public boolean dispatchTrackballEvent(MotionEvent event) {		int action = event.getActionMasked();		if (action == MotionEvent.ACTION_CANCEL				|| action == MotionEvent.ACTION_UP) {			removeAllCallbacks();		}		return super.dispatchTrackballEvent(event);	}		@Override	public void computeScroll() {		if (mSelectorWheelState == SELECTOR_WHEEL_STATE_NONE) {			return;		}		Scroller scroller = mFlingScroller;		if (scroller.isFinished()) {			scroller = mAdjustScroller;			if (scroller.isFinished()) {				return;			}		}		scroller.computeScrollOffset();		if (mHorizontal) {			int currentScrollerX = scroller.getCurrX();			if (mPreviousScrollerX == 0) {				mPreviousScrollerX = scroller.getStartX();			}			scrollBy(currentScrollerX - mPreviousScrollerX, 0);			mPreviousScrollerX = currentScrollerX;		} else {			int currentScrollerY = scroller.getCurrY();			if (mPreviousScrollerY == 0) {				mPreviousScrollerY = scroller.getStartY();			}			scrollBy(0, currentScrollerY - mPreviousScrollerY);			mPreviousScrollerY = currentScrollerY;		}		if (scroller.isFinished()) {			onScrollerFinished(scroller);		} else {			invalidate();		}	}		@Override	public void setEnabled(boolean enabled) {		super.setEnabled(enabled);	}	@Override	public void scrollBy(int x, int y) {		if (mSelectorWheelState == SELECTOR_WHEEL_STATE_NONE) {			return;		}		int[] selectorIndices = mSelectorIndices;		if (!mHorizontal) {			if (!mWrapSelectorWheel && y > 0					&& selectorIndices[mSelectorMiddleItemIndex] <= mMinValue) {				mCurrentScrollOffset = mInitialScrollOffset;				return;			}			if (!mWrapSelectorWheel && y < 0					&& selectorIndices[mSelectorMiddleItemIndex] >= mMaxValue) {				mCurrentScrollOffset = mInitialScrollOffset;				return;			}			mCurrentScrollOffset += y;			while (mCurrentScrollOffset - mInitialScrollOffset > mSelectorTextGapHeight) {				mCurrentScrollOffset -= mSelectorElementHeight;				decrementSelectorIndices(selectorIndices);				changeCurrent(selectorIndices[mSelectorMiddleItemIndex]);				if (!mWrapSelectorWheel						&& selectorIndices[mSelectorMiddleItemIndex] <= mMinValue) {					mCurrentScrollOffset = mInitialScrollOffset;				}			}			while (mCurrentScrollOffset - mInitialScrollOffset < -mSelectorTextGapHeight) {				mCurrentScrollOffset += mSelectorElementHeight;				incrementSelectorIndices(selectorIndices);				changeCurrent(selectorIndices[mSelectorMiddleItemIndex]);				if (!mWrapSelectorWheel						&& selectorIndices[mSelectorMiddleItemIndex] >= mMaxValue) {					mCurrentScrollOffset = mInitialScrollOffset;				}			}		} else {			if (!mWrapSelectorWheel && x > 0					&& selectorIndices[mSelectorMiddleItemIndex] <= mMinValue) {				mCurrentScrollOffset = mInitialScrollOffset;				return;			}			if (!mWrapSelectorWheel && x < 0					&& selectorIndices[mSelectorMiddleItemIndex] >= mMaxValue) {				mCurrentScrollOffset = mInitialScrollOffset;				return;			}			mCurrentScrollOffset += x;			while (mCurrentScrollOffset - mInitialScrollOffset > mSelectorTextGapWidth) {				mCurrentScrollOffset -= mSelectorElementWidth;				decrementSelectorIndices(selectorIndices);				changeCurrent(selectorIndices[mSelectorMiddleItemIndex]);				if (!mWrapSelectorWheel						&& selectorIndices[mSelectorMiddleItemIndex] <= mMinValue) {					mCurrentScrollOffset = mInitialScrollOffset;				}			}			while (mCurrentScrollOffset - mInitialScrollOffset < -mSelectorTextGapWidth) {				mCurrentScrollOffset += mSelectorElementWidth;				incrementSelectorIndices(selectorIndices);				changeCurrent(selectorIndices[mSelectorMiddleItemIndex]);				if (!mWrapSelectorWheel						&& selectorIndices[mSelectorMiddleItemIndex] >= mMaxValue) {					mCurrentScrollOffset = mInitialScrollOffset;				}			}		}	}	@Override	public int getSolidColor() {		return mSolidColor;	}		public void setOnValueChangedListener(			OnValueChangeListener onValueChangedListener) {		mOnValueChangeListener = onValueChangedListener;	}		public void setOnScrollListener(OnScrollListener onScrollListener) {		mOnScrollListener = onScrollListener;	}		public void setFormatter(Formatter formatter) {		if (formatter == mFormatter) {			return;		}		mFormatter = formatter;		initializeSelectorWheelIndices();	}		public void setValue(int value) {		if (mValue == value) {			return;		}		if (value < mMinValue) {			value = mWrapSelectorWheel ? mMaxValue : mMinValue;		}		if (value > mMaxValue) {			value = mWrapSelectorWheel ? mMinValue : mMaxValue;		}		mValue = value;		initializeSelectorWheelIndices();		invalidate();	}		private void tryComputeMaxWidth() {		if (!mComputeMaxWidth) {			return;		}		int maxTextWidth = 0;		if (mDisplayedValues == null) {			float maxDigitWidth = 0;			for (int i = 0; i <= 9; i++) {				final float digitWidth = mSelectorWheelPaint.measureText(String						.valueOf(i));				if (digitWidth > maxDigitWidth) {					maxDigitWidth = digitWidth;				}			}			int numberOfDigits = 0;			int current = mMaxValue;			while (current > 0) {				numberOfDigits++;				current = current / 10;			}			maxTextWidth = (int) (numberOfDigits * maxDigitWidth);		} else {			final int valueCount = mDisplayedValues.length;			for (int i = 0; i < valueCount; i++) {				final float textWidth = mSelectorWheelPaint						.measureText(mDisplayedValues[i]);				if (textWidth > maxTextWidth) {					maxTextWidth = (int) textWidth;				}			}		}		if (mMaxWidth != maxTextWidth) {			if (maxTextWidth > MIN_WIDTH) {				mMaxWidth = maxTextWidth;			} else {				mMaxWidth = MIN_WIDTH;			}			invalidate();		}	}		public boolean getWrapSelectorWheel() {		return mWrapSelectorWheel;	}		public void setWrapSelectorWheel(boolean wrapSelectorWheel) {		if (wrapSelectorWheel				&& (mMaxValue - mMinValue) < mSelectorIndices.length) {			throw new IllegalStateException(					"Range less than selector items count.");		}		if (wrapSelectorWheel != mWrapSelectorWheel) {			mWrapSelectorWheel = wrapSelectorWheel;		}	}		public int getValue() {		return mValue;	}		public int getMinValue() {		return mMinValue;	}		public void setMinValue(int minValue) {		if (mMinValue == minValue) {			return;		}		if (minValue < 0) {			throw new IllegalArgumentException("minValue must be >= 0");		}		mMinValue = minValue;		if (mMinValue > mValue) {			mValue = mMinValue;		}		boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;		setWrapSelectorWheel(wrapSelectorWheel);		initializeSelectorWheelIndices();		tryComputeMaxWidth();	}		public int getMaxValue() {		return mMaxValue;	}		public void setMaxValue(int maxValue) {		if (mMaxValue == maxValue) {			return;		}		if (maxValue < 0) {			throw new IllegalArgumentException("maxValue must be >= 0");		}		mMaxValue = maxValue;		if (mMaxValue < mValue) {			mValue = mMaxValue;		}		boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;		setWrapSelectorWheel(wrapSelectorWheel);		initializeSelectorWheelIndices();		tryComputeMaxWidth();	}		public String[] getDisplayedValues() {		return mDisplayedValues;	}		public void setDisplayedValues(String[] displayedValues) {		if (mDisplayedValues == displayedValues) {			return;		}		mDisplayedValues = displayedValues;		initializeSelectorWheelIndices();		tryComputeMaxWidth();	}		public void setDisplayedValues(String[] displayeValues,			boolean autoCalculateMinMax) {		if (autoCalculateMinMax) {			mMinValue = 0;			mMaxValue = displayeValues.length - 1;		}		setDisplayedValues(displayeValues);	}		@Override	protected void dispatchDraw(Canvas canvas) {		// There is a good reason for doing this. See comments in draw().	}		@Override	public void draw(Canvas canvas) {		super.draw(canvas);	}		@SuppressLint("DrawAllocation")	@Override	protected void onDraw(Canvas canvas) {		if (mSelectorWheelState == SELECTOR_WHEEL_STATE_NONE) {			return;		}		float x = 0.0f;		float y = 0.0f;		float fGapBetweenNumAndScale = mMarginTopOfLabel;		if (!mHorizontal) {			x = fGapBetweenNumAndScale;			y = mCurrentScrollOffset;		} else {			x = mCurrentScrollOffset;			y = fGapBetweenNumAndScale;		}		final int restoreCount = canvas.save();		if (mSelectorWheelState == SELECTOR_WHEEL_STATE_SMALL) {			Rect clipBounds = canvas.getClipBounds();			clipBounds.inset(0, mSelectorElementHeight);			canvas.clipRect(clipBounds);		}		// draw the selector wheel		FontMetricsInt fontMetrics = mSelectorWheelPaint.getFontMetricsInt();		int[] selectorIndices = mSelectorIndices;		for (int i = 0; i < selectorIndices.length; i++) {			int selectorIndex = selectorIndices[i];			String scrollSelectorValue = mSelectorIndexToStringCache					.get(selectorIndex);			if (i - mSelectorMiddleItemIndex > 0) {				mSelectorWheelPaint.setColor(mTextColor);			} else if (i - mSelectorMiddleItemIndex < 0) {				mSelectorWheelPaint.setColor(mTextColor);			} else {				mSelectorWheelPaint.setColor(mTextFocusedColor);			}			float dy = y+ (mTextSize - fontMetrics.bottom + fontMetrics.top) / 2 - fontMetrics.top; 			canvas.drawText(scrollSelectorValue, x, dy, mSelectorWheelPaint);			if (i - mSelectorMiddleItemIndex == 0) {				mSelectorWheelPaint.setColor(mLongScaleLineFocusedColor);			} else {				mSelectorWheelPaint.setColor(mLongScaleLineColor);			}			if(mHorizontal) {				float scaleLeft = x - mLongScaleWidth / 2;				canvas.drawRect(scaleLeft, getHeight() - mScaleLengthShort,						scaleLeft + mLongScaleWidth, getHeight(),						mSelectorWheelPaint);				canvas.drawRect(scaleLeft, 0,						scaleLeft + mLongScaleWidth, mScaleLengthShort,						mSelectorWheelPaint);			}else{				float scaleTop = dy - (mTextSize-mLongScaleWidth) / 2;				canvas.drawRect(0, scaleTop,						mScaleLengthShort, scaleTop + mLongScaleWidth,						mSelectorWheelPaint);				canvas.drawRect(getWidth() - mScaleLengthShort , scaleTop,						getWidth(), scaleTop + mLongScaleWidth,						mSelectorWheelPaint);			}			if (mHorizontal) {				x += mSelectorElementWidth;			} else {				y += mSelectorElementHeight;			}			}		canvas.restoreToCount(restoreCount);	}		@Override	protected float getTopFadingEdgeStrength() {		return TOP_AND_BOTTOM_FADING_EDGE_STRENGTH;	}	@Override	protected float getBottomFadingEdgeStrength() {		return TOP_AND_BOTTOM_FADING_EDGE_STRENGTH;	}	@SuppressLint("MissingSuperCall")	@Override	protected void onDetachedFromWindow() {		removeAllCallbacks();	}		private void incrementSelectorIndices(int[] selectorIndices) {		System.arraycopy(selectorIndices, 1, selectorIndices, 0, selectorIndices.length - 1);		int nextScrollSelectorIndex = selectorIndices[selectorIndices.length - 2] + 1;		if (mWrapSelectorWheel && nextScrollSelectorIndex > mMaxValue) {			nextScrollSelectorIndex = mMinValue;		}		selectorIndices[selectorIndices.length - 1] = nextScrollSelectorIndex;		ensureCachedScrollSelectorValue(nextScrollSelectorIndex);	}		private void changeCurrent(int current) {		if (mValue == current) {			return;		}		// Wrap around the values if we go past the start or end		if (mWrapSelectorWheel) {			current = getWrappedSelectorIndex(current);		}		int previous = mValue;		setValue(current);		notifyChange(previous, current);	}		private void notifyChange(int previous, int current) {		if (mOnValueChangeListener != null) {			mOnValueChangeListener.onValueChange(this, previous, mValue);		}	}		private void decrementSelectorIndices(int[] selectorIndices) {		System.arraycopy(selectorIndices, 0, selectorIndices, 1, selectorIndices.length - 1);		int nextScrollSelectorIndex = selectorIndices[1] - 1;		if (mWrapSelectorWheel && nextScrollSelectorIndex < mMinValue) {			nextScrollSelectorIndex = mMaxValue;		}		selectorIndices[0] = nextScrollSelectorIndex;		ensureCachedScrollSelectorValue(nextScrollSelectorIndex);	}		private void onScrollerFinished(Scroller scroller) {		if (scroller == mFlingScroller) {			if (mSelectorWheelState == SELECTOR_WHEEL_STATE_LARGE) {				postAdjustScrollerCommand(0);				onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);			}		}	}		private void forceCompleteChangeCurrentByOneViaScroll() {		Scroller scroller = mFlingScroller;		if (!scroller.isFinished()) {			if (mHorizontal) {				final int xBeforeAbort = scroller.getCurrX();				scroller.abortAnimation();				final int xDelta = scroller.getCurrX() - xBeforeAbort;				scrollBy(xDelta, 0);			} else {				final int yBeforeAbort = scroller.getCurrY();				scroller.abortAnimation();				final int yDelta = scroller.getCurrY() - yBeforeAbort;				scrollBy(0, yDelta);			}		}	}		private void fling(int velocity) {		mPreviousScrollerY = 0;		mPreviousScrollerX = 0;		int velocityY = velocity;		int velocityX = velocity;		if (mHorizontal) {			if (velocityX > 0) {				mFlingScroller.fling(0, 0, velocityX, 0, 0, Integer.MAX_VALUE,						0, 0);			} else {				mFlingScroller.fling(Integer.MAX_VALUE, 0, velocityX, 0, 0,						Integer.MAX_VALUE, 0, 0);			}		} else {			if (velocityY > 0) {				mFlingScroller.fling(0, 0, 0, velocityY, 0, 0, 0,						Integer.MAX_VALUE);			} else {				mFlingScroller.fling(0, Integer.MAX_VALUE, 0, velocityY, 0, 0,						0, Integer.MAX_VALUE);			}		}		invalidate();	}		private void postAdjustScrollerCommand(int delayMillis) {		if (mAdjustScrollerCommand == null) {			mAdjustScrollerCommand = new AdjustScrollerCommand();		} else {			removeCallbacks(mAdjustScrollerCommand);		}		postDelayed(mAdjustScrollerCommand, delayMillis);	}		private void initializeSelectorWheel() {		initializeSelectorWheelIndices();		int[] selectorIndices = mSelectorIndices;		int totalTextHeight = selectorIndices.length * mTextSize;		int totalTextWidth = (selectorIndices.length - 1) * 2;		// set it horizontal		float totalTextGapHeight = (this.getBottom() - this.getTop())				- totalTextHeight;		float totalTextGapWidth = (this.getRight() - this.getLeft())				- totalTextWidth;		float textGapCount = selectorIndices.length - 1;		if (mHorizontal) {			mSelectorTextGapWidth = (int) (totalTextGapWidth / textGapCount);			mSelectorElementWidth = 2 + mSelectorTextGapWidth;			mInitialScrollOffset = INIT_SCROLL_OFFSET_HORIZONTAL;		} else {			mSelectorTextGapHeight = (int) (totalTextGapHeight / textGapCount + 0.5f);			mSelectorElementHeight = mTextSize + mSelectorTextGapHeight;			mInitialScrollOffset = INIT_SCROLL_OFFSET_VERTICAL;		}		mCurrentScrollOffset = mInitialScrollOffset;	}		private void initializeFadingEdges() {		setVerticalFadingEdgeEnabled(true);		setFadingEdgeLength((this.getBottom() - this.getTop() - mTextSize) / 2);	}		private void initializeSelectorWheelIndices() {		mSelectorIndexToStringCache.clear();		int current = getValue();		for (int i = 0; i < mSelectorIndices.length; i++) {			int selectorIndex = current + (i - mSelectorMiddleItemIndex);			if (mWrapSelectorWheel) {				selectorIndex = getWrappedSelectorIndex(selectorIndex);			}			mSelectorIndices[i] = selectorIndex;			ensureCachedScrollSelectorValue(mSelectorIndices[i]);		}	}		private int getWrappedSelectorIndex(int selectorIndex) {		if (selectorIndex > mMaxValue) {			return mMinValue + (selectorIndex - mMaxValue)					% (mMaxValue - mMinValue) - 1;		} else if (selectorIndex < mMinValue) {			return mMaxValue - (mMinValue - selectorIndex)					% (mMaxValue - mMinValue) + 1;		}		return selectorIndex;	}		private void ensureCachedScrollSelectorValue(int selectorIndex) {		SparseArray<String> cache = mSelectorIndexToStringCache;		String scrollSelectorValue = cache.get(selectorIndex);		if (scrollSelectorValue != null) {			return;		}		if (selectorIndex < mMinValue || selectorIndex > mMaxValue) {			scrollSelectorValue = "";		} else {			if (mDisplayedValues != null) {				int displayedValueIndex = selectorIndex - mMinValue;				scrollSelectorValue = mDisplayedValues[displayedValueIndex];			} else {				scrollSelectorValue = formatNumber(selectorIndex);			}		}		cache.put(selectorIndex, scrollSelectorValue);	}		private String formatNumber(int value) {		return (mFormatter != null) ? mFormatter.format(value) : String				.valueOf(value);	}		public interface Formatter {		String format(int value);	}		class AdjustScrollerCommand implements Runnable {		public void run() {			mPreviousScrollerY = 0;			mPreviousScrollerX = 0;			if (mInitialScrollOffset == mCurrentScrollOffset) {				return;			}			if (mHorizontal) {				// adjust to the closest value				int deltaX = mInitialScrollOffset - mCurrentScrollOffset;				mAdjustScroller.startScroll(0, 0, deltaX, 0,						SELECTOR_ADJUSTMENT_DURATION_MILLIS);			} else {				// adjust to the closest value				int deltaY = mInitialScrollOffset - mCurrentScrollOffset;				if (Math.abs(deltaY) > mSelectorElementHeight / 2) {					deltaY += (deltaY > 0) ? -mSelectorElementHeight							: mSelectorElementHeight;				}				mAdjustScroller.startScroll(0, 0, 0, deltaY,						SELECTOR_ADJUSTMENT_DURATION_MILLIS);			}			invalidate();		}	}	public int getTextColor() {		return mTextColor;	}	public void setTextColor(int mTextColor) {		this.mTextColor = mTextColor;	}	public int getTextFocusedColor() {		return mTextFocusedColor;	}	public void setTextFocusedColor(int mTextFocusedColor) {		this.mTextFocusedColor = mTextFocusedColor;	}	public int getLongScaleLineColor() {		return mLongScaleLineColor;	}	public void setLongScaleLineColor(int mLongScaleLineColor) {		this.mLongScaleLineColor = mLongScaleLineColor;	}	public int getLongScaleLineFocusedColor() {		return mLongScaleLineFocusedColor;	}	public void setLongScaleLineFocusedColor(int mLongScaleLineFocusedColor) {		this.mLongScaleLineFocusedColor = mLongScaleLineFocusedColor;	}	public float getScaleLengthShort() {		return mScaleLengthShort;	}	public void setScaleLengthShort(float mScaleLengthShort) {		this.mScaleLengthShort = mScaleLengthShort;	}	public float getMarginTopOfLabel() {		return mMarginTopOfLabel;	}	public void setMarginTopOfLabel(float mMarginTopOfLabel) {		this.mMarginTopOfLabel = mMarginTopOfLabel;	}	public float getLongScaleWidth() {		return mLongScaleWidth;	}	public void setLongScaleWidth(float mLongScaleWidth) {		this.mLongScaleWidth = mLongScaleWidth;	}	public int getTextSize() {		return mTextSize;	}	public void setHorizontal(boolean mHorizontal) {		this.mHorizontal = mHorizontal;	}	@Override	public void setOnTouchListener(OnTouchListener l) {		// TODO Auto-generated method stub		mOnTouchListener = l;	}	}