package six.lwuikit.bar;import six.lwuikit.saf.RE;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Bitmap;import android.graphics.BitmapShader;import android.graphics.Canvas;import android.graphics.Rect;import android.graphics.Shader;import android.graphics.drawable.Animatable;import android.graphics.drawable.AnimatedRotateDrawable;import android.graphics.drawable.AnimationDrawable;import android.graphics.drawable.BitmapDrawable;import android.graphics.drawable.ClipDrawable;import android.graphics.drawable.Drawable;import android.graphics.drawable.LayerDrawable;import android.graphics.drawable.ShapeDrawable;import android.graphics.drawable.StateListDrawable;import android.graphics.drawable.shapes.RoundRectShape;import android.graphics.drawable.shapes.Shape;import android.util.AttributeSet;import android.view.Gravity;import android.view.RemotableViewMethod;import android.view.View;import android.view.ViewDebug;import android.view.animation.AlphaAnimation;import android.view.animation.Animation;import android.view.animation.AnimationUtils;import android.view.animation.Interpolator;import android.view.animation.LinearInterpolator;import android.view.animation.Transformation;import android.widget.RemoteViews.RemoteView;import com.android.internal.R;@RemoteViewpublic class IProgressBar extends View{		private static final int MAX_LEVEL = 10000;	static final int TIMEOUT_SEND_ACCESSIBILITY_EVENT = 200;		int mMinWidth;    int mMaxWidth;    int mMinHeight;    int mMaxHeight;        private int mBehavior;    private int mDuration;    private boolean mIndeterminate;    private boolean mOnlyIndeterminate;    private boolean mNoInvalidate;        private Drawable mIndeterminateDrawable;    private Drawable mCurrentDrawable;    private Interpolator mInterpolator;    Bitmap mSampleTile;    private Transformation mTransformation;    private AlphaAnimation mAnimation;        private boolean mShouldStartAnimationDrawable;    private boolean mHasAnimation;    private boolean mAnimatable = false;    boolean mMirrorForRtl = false;    private boolean mInDrawing;    private boolean mAttached;    		public IProgressBar(Context context) {        this(context, null);    }        public IProgressBar(Context context, AttributeSet attrs) {        this(context, attrs, com.android.internal.R.attr.progressBarStyle);    }    public IProgressBar(Context context, AttributeSet attrs, int defStyle) {        this(context, attrs, defStyle, 0);    }	public IProgressBar(Context context, AttributeSet attrs, int defStyle, int styleRes) {		super(context, attrs, defStyle);		// TODO Auto-generated constructor stub		initProgressBar();		TypedArray a =	            context.obtainStyledAttributes(attrs, R.styleable.ProgressBar, defStyle, styleRes);	    mNoInvalidate = true;	    mDuration = a.getInt(R.styleable.ProgressBar_indeterminateDuration, mDuration);        mMinWidth = a.getDimensionPixelSize(R.styleable.ProgressBar_minWidth, mMinWidth);        mMaxWidth = a.getDimensionPixelSize(R.styleable.ProgressBar_maxWidth, mMaxWidth);        mMinHeight = a.getDimensionPixelSize(R.styleable.ProgressBar_minHeight, mMinHeight);        mMaxHeight = a.getDimensionPixelSize(R.styleable.ProgressBar_maxHeight, mMaxHeight);        mBehavior = a.getInt(R.styleable.ProgressBar_indeterminateBehavior, mBehavior);        final int resID = a.getResourceId(                com.android.internal.R.styleable.ProgressBar_interpolator,                 android.R.anim.linear_interpolator); // default to linear interpolator        if (resID > 0) {            setInterpolator(context, resID);        }        Drawable drawable = a.getDrawable(R.styleable.ProgressBar_indeterminateDrawable);        if (drawable != null) {            drawable = tileifyIndeterminate(drawable);            setIndeterminateDrawable(drawable);        }        mOnlyIndeterminate = a.getBoolean(                R.styleable.ProgressBar_indeterminateOnly, mOnlyIndeterminate);        mNoInvalidate = false;        setIndeterminate(mOnlyIndeterminate || a.getBoolean(                R.styleable.ProgressBar_indeterminate, mIndeterminate));        mMirrorForRtl = a.getBoolean(R.styleable.ProgressBar_mirrorForRtl, mMirrorForRtl);        a.recycle();        TypedArray a1 = context.obtainStyledAttributes(attrs, RE.styleable_IProgressBar);		if(null != a1){			int index = RE.get(RE.ATTR_FRAMESDURATION);			if(index >= 0){				setFramesDuration(a.getInt(index, 10));			}			index = RE.get(RE.ATTR_FRAMESCOUNT);			if(index >= 0){				setFramesCount(a.getInt(index, 110));			}			a1.recycle();		}	}	private void initProgressBar() {		mIndeterminate = false;		mOnlyIndeterminate = false;		mDuration = 4000;		mBehavior = AlphaAnimation.RESTART;		mMinWidth = 24;		mMaxWidth = 48;		mMinHeight = 24;		mMaxHeight = 48;	}		private Drawable tileifyIndeterminate(Drawable drawable) {        if (drawable instanceof AnimationDrawable) {            AnimationDrawable background = (AnimationDrawable) drawable;            final int N = background.getNumberOfFrames();            AnimationDrawable newBg = new AnimationDrawable();            newBg.setOneShot(background.isOneShot());                        for (int i = 0; i < N; i++) {                Drawable frame = tileify(background.getFrame(i), true);                frame.setLevel(10000);                newBg.addFrame(frame, background.getDuration(i));            }            newBg.setLevel(10000);            drawable = newBg;        }        return drawable;    }		private Drawable tileify(Drawable drawable, boolean clip) {		if (drawable instanceof LayerDrawable) {			LayerDrawable background = (LayerDrawable) drawable;			final int N = background.getNumberOfLayers();			Drawable[] outDrawables = new Drawable[N];			for (int i = 0; i < N; i++) {				int id = background.getId(i);				outDrawables[i] = tileify(background.getDrawable(i),						(id == R.id.progress || id == R.id.secondaryProgress));			}			LayerDrawable newBg = new LayerDrawable(outDrawables);			for (int i = 0; i < N; i++) {				newBg.setId(i, background.getId(i));			}			return newBg;		} else if (drawable instanceof StateListDrawable) {			StateListDrawable in = (StateListDrawable) drawable;			StateListDrawable out = new StateListDrawable();			int numStates = in.getStateCount();			for (int i = 0; i < numStates; i++) {				out.addState(in.getStateSet(i),						tileify(in.getStateDrawable(i), clip));			}			return out;		} else if (drawable instanceof BitmapDrawable) {			final Bitmap tileBitmap = ((BitmapDrawable) drawable).getBitmap();			if (mSampleTile == null) {				mSampleTile = tileBitmap;			}			final ShapeDrawable shapeDrawable = new ShapeDrawable(					getDrawableShape());			final BitmapShader bitmapShader = new BitmapShader(tileBitmap,					Shader.TileMode.REPEAT, Shader.TileMode.CLAMP);			shapeDrawable.getPaint().setShader(bitmapShader);			return (clip) ? new ClipDrawable(shapeDrawable, Gravity.LEFT,					ClipDrawable.HORIZONTAL) : shapeDrawable;		}		return drawable;	}		Shape getDrawableShape() {        final float[] roundedCorners = new float[] { 5, 5, 5, 5, 5, 5, 5, 5 };        return new RoundRectShape(roundedCorners, null, null);    }		Drawable getCurrentDrawable() {        return mCurrentDrawable;    }		public void setInterpolator(Context context, int resID) {        setInterpolator(AnimationUtils.loadInterpolator(context, resID));    }	public void setInterpolator(Interpolator interpolator) {		mInterpolator = interpolator;	}		public void setIndeterminateDrawable(Drawable d) {        if (d != null) {            d.setCallback(this);        }        mIndeterminateDrawable = d;        if (mIndeterminateDrawable != null && canResolveLayoutDirection()) {            mIndeterminateDrawable.setLayoutDirection(getLayoutDirection());        }        if (mIndeterminate) {            mCurrentDrawable = d;            postInvalidate();        }    }		@android.view.RemotableViewMethod	public synchronized void setIndeterminate(boolean indeterminate) {		if ((!mOnlyIndeterminate || !mIndeterminate)				&& indeterminate != mIndeterminate) {			mIndeterminate = indeterminate;			if (indeterminate) {				// swap between indeterminate and regular backgrounds				mCurrentDrawable = mIndeterminateDrawable;				start();			} else {				mCurrentDrawable = null;				stop();			}		}	}		private void start() {        if (getVisibility() != VISIBLE) {            return;        }        if (mIndeterminateDrawable instanceof Animatable) {            mShouldStartAnimationDrawable = true;            mHasAnimation = false;        } else {            mHasAnimation = true;            if (mInterpolator == null) {                mInterpolator = new LinearInterpolator();            }                if (mTransformation == null) {                mTransformation = new Transformation();            } else {                mTransformation.clear();            }                        if (mAnimation == null) {                mAnimation = new AlphaAnimation(0.0f, 1.0f);            } else {                mAnimation.reset();            }            mAnimation.setRepeatMode(mBehavior);            mAnimation.setRepeatCount(Animation.INFINITE);            mAnimation.setDuration(mDuration);            mAnimation.setInterpolator(mInterpolator);            mAnimation.setStartTime(Animation.START_ON_FIRST_FRAME);        }        postInvalidate();    }		private void stop() {        mHasAnimation = false;        if (mIndeterminateDrawable instanceof Animatable) {            ((Animatable) mIndeterminateDrawable).stop();            mShouldStartAnimationDrawable = false;                   }        postInvalidate();    }		public void startAnimation() {		 mAnimatable = true;		 start();	}		public void stopAnimation() {		mAnimatable = false;		stop();	}		@ViewDebug.ExportedProperty(category = "progress")    public synchronized boolean isIndeterminate() {        return mIndeterminate;    }		public Drawable getIndeterminateDrawable() {        return mIndeterminateDrawable;    }		@Override    protected boolean verifyDrawable(Drawable who) {        return who == mIndeterminateDrawable                || super.verifyDrawable(who);    }    @Override    public void jumpDrawablesToCurrentState() {        super.jumpDrawablesToCurrentState();        if (mIndeterminateDrawable != null) mIndeterminateDrawable.jumpToCurrentState();    }        @Override    public void onResolveDrawables(int layoutDirection) {        final Drawable d = mCurrentDrawable;        if (d != null) {            d.setLayoutDirection(layoutDirection);        }        if (mIndeterminateDrawable != null) {            mIndeterminateDrawable.setLayoutDirection(layoutDirection);        }    }        @Override    public void postInvalidate() {        if (!mNoInvalidate) {            super.postInvalidate();        }    }        public Interpolator getInterpolator() {        return mInterpolator;    }        @Override    @RemotableViewMethod    public void setVisibility(int v) {        if (getVisibility() != v) {            super.setVisibility(v);            if (mIndeterminate) {                // let's be nice with the UI thread                if (v == GONE || v == INVISIBLE) {                    stop();                } else {                	if (null != mIndeterminateDrawable) {    					if (mIndeterminateDrawable instanceof Animatable) {    						if (!mAnimatable) {    							stop();    						} else {    							start();    						}    					} else {    						start();    					}    				}else{    					start();    				}                }            }        }    }    @Override    protected void onVisibilityChanged(View changedView, int visibility) {        super.onVisibilityChanged(changedView, visibility);        if (mIndeterminate) {            if (visibility == GONE || visibility == INVISIBLE) {                stop();            } else {				if (null != mIndeterminateDrawable) {					if (mIndeterminateDrawable instanceof Animatable) {						if (!mAnimatable) {							stop();						} else {							start();						}					} else {						start();					}				}else{					start();				}            }        }    }    @Override    public void invalidateDrawable(Drawable dr) {        if (!mInDrawing) {            if (verifyDrawable(dr)) {                final Rect dirty = dr.getBounds();                invalidate(dirty.left + mScrollX, dirty.top + mScrollY,                        dirty.right + mScrollX, dirty.bottom + mScrollY);            } else {                super.invalidateDrawable(dr);            }        }    }        @Override    protected void onSizeChanged(int w, int h, int oldw, int oldh) {        updateDrawableBounds(w, h);    }    private void updateDrawableBounds(int w, int h) {        // onDraw will translate the canvas so we draw starting at 0,0.        // Subtract out padding for the purposes of the calculations below.        w -= mPaddingRight + mPaddingLeft;        h -= mPaddingTop + mPaddingBottom;        int right = w;        int bottom = h;        int top = 0;        int left = 0;        if (mIndeterminateDrawable != null) {            // Aspect ratio logic does not apply to AnimationDrawables            if (mOnlyIndeterminate && !(mIndeterminateDrawable instanceof AnimationDrawable)) {                // Maintain aspect ratio. Certain kinds of animated drawables                // get very confused otherwise.                final int intrinsicWidth = mIndeterminateDrawable.getIntrinsicWidth();                final int intrinsicHeight = mIndeterminateDrawable.getIntrinsicHeight();                final float intrinsicAspect = (float) intrinsicWidth / intrinsicHeight;                final float boundAspect = (float) w / h;                if (intrinsicAspect != boundAspect) {                    if (boundAspect > intrinsicAspect) {                        // New width is larger. Make it smaller to match height.                        final int width = (int) (h * intrinsicAspect);                        left = (w - width) / 2;                        right = left + width;                    } else {                        // New height is larger. Make it smaller to match width.                        final int height = (int) (w * (1 / intrinsicAspect));                        top = (h - height) / 2;                        bottom = top + height;                    }                }            }            if (isLayoutRtl() && mMirrorForRtl) {                int tempLeft = left;                left = w - right;                right = w - tempLeft;            }            mIndeterminateDrawable.setBounds(left, top, right, bottom);        }    }        @Override    protected synchronized void onDraw(Canvas canvas) {        super.onDraw(canvas);        Drawable d = mCurrentDrawable;        if (d != null) {            // Translate canvas so a indeterminate circular progress bar with padding            // rotates properly in its animation            canvas.save();            if(isLayoutRtl() && mMirrorForRtl) {                canvas.translate(getWidth() - mPaddingRight, mPaddingTop);                canvas.scale(-1.0f, 1.0f);            } else {                canvas.translate(mPaddingLeft, mPaddingTop);            }            long time = getDrawingTime();            if (mHasAnimation) {                mAnimation.getTransformation(time, mTransformation);                float scale = mTransformation.getAlpha();                try {                    mInDrawing = true;                    d.setLevel((int) (scale * MAX_LEVEL));                } finally {                    mInDrawing = false;                }                postInvalidateOnAnimation();            }            d.draw(canvas);            canvas.restore();            if (mShouldStartAnimationDrawable && d instanceof Animatable) {                ((Animatable) d).start();                mShouldStartAnimationDrawable = false;            }        }    }    @Override    protected synchronized void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        Drawable d = mCurrentDrawable;        int dw = 0;        int dh = 0;        if (d != null) {            dw = Math.max(mMinWidth, Math.min(mMaxWidth, d.getIntrinsicWidth()));            dh = Math.max(mMinHeight, Math.min(mMaxHeight, d.getIntrinsicHeight()));        }        updateDrawableState();        dw += mPaddingLeft + mPaddingRight;        dh += mPaddingTop + mPaddingBottom;        setMeasuredDimension(resolveSizeAndState(dw, widthMeasureSpec, 0),                resolveSizeAndState(dh, heightMeasureSpec, 0));    }        @Override    protected void drawableStateChanged() {        super.drawableStateChanged();        updateDrawableState();    }        private void updateDrawableState() {        int[] state = getDrawableState();        if (mIndeterminateDrawable != null && mIndeterminateDrawable.isStateful()) {            mIndeterminateDrawable.setState(state);        }    }        @Override    protected void onAttachedToWindow() {        super.onAttachedToWindow();        if (mIndeterminate) {        	 if (null != mIndeterminateDrawable) {        		 if(mIndeterminateDrawable instanceof Animatable) {        			 if(!mAnimatable) {                    	 stop();                      }else{                    	 start();                     }        		 }else{        			 start();        		 }             }        }        mAttached = true;    }    @Override    protected void onDetachedFromWindow() {        if (mIndeterminate) {            stop();        }        super.onDetachedFromWindow();        mAttached = false;    }	public boolean isAttached() {		return mAttached;	}		public void setFramesDuration(int duration) {		if(null != mIndeterminateDrawable && 				(mIndeterminateDrawable instanceof AnimatedRotateDrawable)) {			((AnimatedRotateDrawable)mIndeterminateDrawable).setFramesDuration(duration);		}	}		public void setFramesCount(int count) {		if(null != mIndeterminateDrawable && 				(mIndeterminateDrawable instanceof AnimatedRotateDrawable)) {			((AnimatedRotateDrawable)mIndeterminateDrawable).setFramesCount(count);		}	}	}